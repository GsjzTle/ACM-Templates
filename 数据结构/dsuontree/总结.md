**过程**

+ 对于当前以 $root$ 为根的树，先去处理其轻子树，处理完轻子树后将轻子树所记录的信息删除，等轻子树全部处理完后再去处理其重子树，处理完重子树后将重子树所记录的信息保留，然后回到当前以 $root$ 为根的树，开始处理以 $root$ 为根的树。
+ $root$ 保留了其重子树的信息，而没有轻子树的信息，因此需要再次遍历所有轻子树，并计算 <$root$，重子树>、<$root$，轻子树> 、<重子树、轻子树>、<轻子树，轻子树>（不同分会）之间所产生的贡献。等全部计算完后，判断 $root$ 是不是它爸爸的重儿子，如果是就保留 $root$ 及其全部子树的所有信息，若不是则删除 $root$ 及其全部子树的所有信息。

**套路**

+ 如果计算贡献的式子中包含 $dis(u,v)$，那么就把 $dis(u,v)$ 拆解为 $dep_u+dep_v-2dep_{LCA}$
  于是就可以以 $LCA$ 为 $root$，$u,v$ 为其不同分支中的点，跑 $dsu~on~tree$ 计算贡献

