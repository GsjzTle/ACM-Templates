## 题目链接

[点我跳转](https://codeforces.com/contest/1417/problem/E)

## 题目大意

> 给定一个长度为 $N$ 的数组 $A$
>
> 要求你找到一个 $X$ 使得 $Bi = Ai ⊕ X$ ，其中数组 $B$ 的逆序对数最少
>
> 如果存在多个满足条件的 $X$ , 则输出最小的那个

## 解题思路

>**贪心+分治**
>
>大致思路如下图
>
>![image-20201008204542553](C:\Users\48939\AppData\Roaming\Typora\typora-user-images\image-20201008204542553.png)
>
>然后按照图示模拟一下即可

## AC_Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 3e5 + 10;
int cnt[N][2] , a[N];
vector<int>vec;
void dfs(vector<int>vec , int i)
{
	if(i < 0) return ;
	int res1 = 0 , res2 = 0 , cnt1 = 0 , cnt2 = 0;
	for(auto j : vec)
	{
		int x = j >> i & 1 ^ 1;
		if(!x) res1 += cnt1;
		else res2 += cnt2;
		if(x) cnt1 ++ ; 
		else cnt2 ++ ; 
	} 
	cnt[i][0] += res2 , cnt[i][1] += res1;
	vector<int>vec1 , vec2;
	for(auto j : vec)
	{
		if(j >> i & 1) vec1.push_back(j);
		else vec2.push_back(j);
	}
	if(vec1.size()) dfs(vec1 , i - 1) ; 
	if(vec2.size()) dfs(vec2 , i - 1);
} 
signed main()
{
	int n , ans = 0 , tot = 0;
	cin >> n;
	for(int i = 1 ; i <= n ; i ++) cin >> a[i] , vec.push_back(a[i]);
	dfs(vec , 31);
	for(int i = 31 ; ~i ; i --)
	{
		if(cnt[i][0] > cnt[i][1]) ans += 1LL << i , tot += cnt[i][1];
		else tot += cnt[i][0];
	}
	cout << tot << " " << ans << '\n';
	return 0;
}
```

